# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Usage: has <command>
#
# Returns 0 if the <command> is available. Returns 1 otherwise. It can be a
# binary in the PATH or a shell function.
#
# Example:
#
#    if has curl; then
#      echo "Yes we do"
#    fi
#
# Taken from https://github.com/direnv/direnv/blob/master/stdlib.sh
has() {
  type "$1" &>/dev/null
}

# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:/usr/local/bin:$PATH

[[ -d "$HOME/.local/bin"  ]] && export PATH=$HOME/.local/bin:$PATH
[[ -d "$HOME/.npm-global" ]] && export PATH=$HOME/.npm-global/bin:$PATH
[[ -d "$HOME/.local/bin"  ]] && export PATH=$HOME/.local/bin:$PATH # "pip install --user" installs executables to this location
[[ -d "$HOME/bin"         ]] && export PATH="$HOME/bin:$PATH"

ZSH_THEME="powerlevel10k/powerlevel10k"
# ZSH_THEME="robbyrussell"

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment the following line to disable bi-weekly auto-update checks.
# DISABLE_AUTO_UPDATE="true"

# Uncomment the following line to automatically update without prompting.
# DISABLE_UPDATE_PROMPT="true"

# Uncomment the following line to change how often to auto-update (in days).
# export UPDATE_ZSH_DAYS=13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS=true

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS="mm/dd/yyyy"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in ~/.oh-my-zsh/plugins/*
# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git)
tryplugins=(npm yarn dnf gulp tmux aws kubectl minikube pip docker postgres nvm)
for p in $tryplugins; do
  if has "$p"; then
    plugins+=("$p")
  fi
done
if has docker; then
  plugins+=('fzf-docker')
fi

# brew autocomplete
if type brew &>/dev/null
then
  FPATH="$(brew --prefix)/share/zsh/site-functions:${FPATH}"

  autoload -Uz compinit
  compinit
fi

source $HOME/.oh-my-zsh/oh-my-zsh.sh

{
  # override theme
  git_upstream_difference() {
    local is_git_repository=$(git rev-parse --is-inside-work-tree &>/dev/null)
    local git_upstream_difference=""
    if test -n is_git_repository; then
      git rev-parse --abbrev-ref '@{upstream}' &> /dev/null && local has_upstream=1
      if [[ -n "$has_upstream" ]]; then
        local commit_counts=$(git rev-list --left-right --count 'HEAD...@{upstream}' 2> /dev/null)
        local commits_to_push=$(echo $commit_counts | cut -f 1 2> /dev/null)
        local commits_to_pull=$(echo $commit_counts | cut -f 2 2> /dev/null)
      fi
      if [[ "$commits_to_push" -ne "0" ]]; then
        if [[ "$commits_to_pull" != 0 ]]; then
          local git_outgoing_color=$fg[red]
        elif [[ "$commits_to_push" > 3 ]]; then
          local git_outgoing_color=$fg[yellow]
        else
          local git_outgoing_color=$fg[green]
        fi
        local git_upstream_difference="${git_upstream_difference}⇡"
      fi
      if [[ "$commits_to_pull" -ne 0 ]]; then
        if [[ "$commits_to_push" != 0 ]]; then
          local git_incoming_color=$fg[red]
        elif [[ "$commits_to_pull" > 3 ]]; then
          local git_incoming_color=$fg[yellow]
        else
          local git_incoming_color=$fg[green]
        fi
        local git_upstream_difference="${git_upstream_difference}⇣"
      fi
    fi
    echo $git_upstream_difference
  }
  git_prompt_info() {
    local ref
    if [[ "$(command git config --get oh-my-zsh.hide-status 2>/dev/null)" != "1" ]]; then
      ref=$(command git symbolic-ref HEAD 2> /dev/null) || \
      ref=$(command git rev-parse --short HEAD 2> /dev/null) || return 0
      echo "$ZSH_THEME_GIT_PROMPT_PREFIX${ref#refs/heads/}$ZSH_THEME_GIT_PROMPT_SUFFIX"
    fi
  }

  PROMPT="%(?:%{$fg_bold[green]%}➜:%{$fg_bold[red]%}➜)"
  PROMPT+=' %{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)$(git_upstream_difference)$(parse_git_dirty) %{$reset_color%}'

  ZSH_THEME_GIT_PROMPT_PREFIX="%{$fg_bold[blue]%}(%{$fg[red]%}"
  ZSH_THEME_GIT_PROMPT_SUFFIX="%{$fg[blue]%})%{$reset_color%}"
  ZSH_THEME_GIT_PROMPT_DIRTY=" %{$fg[yellow]%}✗"
  ZSH_THEME_GIT_PROMPT_CLEAN=""
}

ZSH_THEME_TERM_TITLE_IDLE='%1d'
# export ZSH_THEME_TERM_TAB_TITLE_IDLE='%1d'
# https://github.com/ohmyzsh/ohmyzsh/wiki/Settings#zsh_theme_term_title_idle
# https://zsh.sourceforge.io/Doc/Release/Prompt-Expansion.html

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='mvim'
# fi

setopt complete_aliases
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
[ -d ~/.config/zsh/zsh-autosuggestions ] && source ~/.config/zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
[ -d ~/.config/zsh/zsh-syntax-highlighting ] && source ~/.config/zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
[ -f ~/.config/zsh/fzf-git.sh ] && source ~/.config/zsh/fzf-git.sh
[ -f /opt/homebrew/etc/profile.d/autojump.sh ] && . /opt/homebrew/etc/profile.d/autojump.sh
if has jump; then
  eval "$(jump shell zsh)"
fi
local vim_cmd=vim
if has nvim; then
  vim_cmd=nvim
  alias nvimdiff='nvim -d'
fi
if has git-number; then
  alias g='git number'
  if has compdef; then
    compdef g=git
  fi
  alias gim="git-number -c $vim_cmd"
  alias giff="git-number -c $vim_cmd +Gvdiff"
fi
alias gs="$vim_cmd"' +0Git "+normal gU"'
alias v="$vim_cmd"
unset vim_cmd

if [[ "$(uname)" == "Linux" ]]; then
  alias open="xdg-open"
  if ! grep -q Microsoft /proc/version; then
    alias pbcopy='xsel --clipboard --input'
    alias pbpaste='xsel --clipboard --output'
  else
    alias pbcopy='clip.exe'
    alias pbpaste='powershell.exe -command "Get-Clipboard"'
  fi
fi

if has fzf; then
  fzfCommit() {
    local FZF_PROMPT="${FZF_PROMPT:=Commit: }"
    git log --oneline | fzf --border --prompt="$FZF_PROMPT" --height=10         --preview="git show {+1} --color=always" --no-sort --reverse | cut -d' ' -f1 | tr '\n' ' ' | sed 's/[[:space:]]$//';
  }
  fzfCommits() {
    local FZF_PROMPT="${FZF_PROMPT:=Commit: }"
    git log --oneline | fzf --border --prompt="$FZF_PROMPT" --height=10 --multi --preview="git show {+1} --color=always" --no-sort --reverse | cut -d' ' -f1 | tr '\n' ' ' | sed 's/[[:space:]]$//'
  }
  fzfTags() {
    git tag | grep -v HEAD | sed "s/.* //" | sed "s#remotes/##" | sort -u | fzf --border --prompt='Tag: ' --height=30 --multi --preview="git log --format=medium --graph --max-count 10 {+1}" | tr '\n' ' ' | sed 's/[[:space:]]$//'
  }
  fzfBranches() {
    git branch --all | grep -v HEAD | sed "s/.* //" | sed "s#remotes/##" | sort -u | fzf --border --prompt='Branch: ' --height=60% --multi --preview="git log --graph --max-count=10 {+1}" | tr '\n' ' ' | sed 's/[[:space:]]$//'
  }
  insertCommits() {
    if [[ "$LBUFFER[-1]" != "!" ]]; then
      LBUFFER+='C'
      return 0
    fi
    LBUFFER="${LBUFFER[1,-2]}$(fzfCommits)"
    local ret=$?
    zle reset-prompt
    return $ret
  }
  insertTags() {
    if [[ "$LBUFFER[-1]" != "!" ]]; then
      LBUFFER+='T'
      return 0
    fi
    LBUFFER="${LBUFFER[1,-2]}$(fzfTags)"
    local ret=$?
    zle reset-prompt
    return $ret
  }
  insertBranches() {
    if [[ "$LBUFFER[-1]" != "!" ]]; then
      LBUFFER+='B'
      return 0
    fi
    LBUFFER="${LBUFFER[1,-2]}$(fzfBranches)"
    local ret=$?
    zle reset-prompt
    return $ret
  }

  zle -N insertCommits
  bindkey C insertCommits
  zle -N insertTags
  bindkey T insertTags
  zle -N insertBranches
  bindkey B insertBranches
fi

function gfixup {
  local commit=$(FZF_PROMPT='Fixup Commit: ' fzfCommit)
  if [[ -z "$commit" ]]; then
    return 1
  fi
  set -x
  git commit --fixup "$commit" --allow-empty > /dev/null || return 1
  git rebase --interactive "$commit"~ --autosquash || return 1
}

if has git-mob && has fzf; then
  function gmob() {
    local selected=$(git mob -l \
      | fzf --multi \
        --layout=reverse \
        --height=11 \
        --border=rounded \
        --prompt='🦜 Pair with ' \
      | awk '{print $1;}' \
      | tr '\n' ' ' \
      | sed 's/,//g' )
    [[ -n "$selected" ]] && git mob $(echo $selected)
  }
fi

if has _fzf_git_each_ref; then
  unalias gco
  function gco() {
    local selected=$(_fzf_git_each_ref --no-multi)
    [[ -n "$selected" ]] && echo git checkout "$selected"
  }
fi

[[ -d "$HOME/.nvm" ]] && {
  export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" # This loads nvm
}

[[ -d "$HOME/.cargo" ]] && {
  export PATH=$HOME/.cargo/bin:$PATH
}
if [[ -f /proc/version ]] && grep -q Microsoft /proc/version; then
  echo 'this is windows'
fi

if has rg; then
  export FZF_DEFAULT_COMMAND="rg --hidden --files --glob !.git"
  export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
fi
export FZF_DEFAULT_OPTS='
  --info=inline
  --bind ctrl-q:toggle-all
  --bind ctrl-j:preview-down
  --bind ctrl-k:preview-up
  --bind ctrl-d:preview-page-down
  --bind ctrl-u:preview-page-up
  --pointer=➜
  --ellipsis=…
  --marker=✓
  --bind ctrl-'"\\\\"':toggle-preview
  --bind '"'"'alt-q:change-preview-window(right,70%|down,40%,border-horizontal|hidden|right)'"'"'
  --bind '"'"'alt-Q:change-preview-window(right|hidden|down,40%,border-horizontal|right,70%)'"'"'
  --bind ctrl-y:preview-up
  --bind ctrl-r:prev-history
  --bind ctrl-t:next-history
  --bind ctrl-p:up
  --bind ctrl-n:down
  '
# select previous       | ctrl-p | :-( not show previous history search
# carot to end          | ctrl-e | :-( not scroll down
# carot to start        | ctrl-a |
# preview down          | ctrl-j | :-( not select next
# preview page down     | ctrl-d | :-( not delete char
# preview page up       | ctrl-u |
# preview up            | ctrl-k | :-( not kill line :-( not select previous
# rotate preview layout | alt-Q  |
# rotate preview layout | alt-q  |
# toggle all items      | alt-a  |
# toggle all items      | ctrl-q |
# toggle preview        | ctrl-/ | ??? doesn't work in kitty/nvim
# toggle preview        | ctrl-\ |

if has direnv; then
  eval "$(direnv hook zsh)"
fi

if [[ "$TERM" = "xterm-kitty" ]]; then
  alias icat="kitty +kitten icat"
  alias hg="kitty +kitten hyperlinked_grep "
  compdef hg=rg
  # https://www.baeldung.com/linux/background-process-get-exit-code
  notify() {
    local errcode="$?"
    local title
    local prev_cmd="$(tail -n 1 $HISTFILE | sed 's/^[^;]*;//')"
    if [[ "$errcode" = "0" ]]; then
      title="${1:-✅ $prev_cmd}"
    else
      title="${1:-❌ $prev_cmd}"
    fi
    local body="$2"
    printf '\x1b]99;i=1:d=0;'"$title"'\x1b\\'
    printf '\x1b]99;i=1:d=1:p=body;'"$body"'\x1b\\'
  }
  alias n=notify
  rk_mark() {
    kitty @ --password 'wow such secure' create-marker --match all text 3 "$1"
  }
  rk_unmark() {
    kitty @ --password 'wow such secure' remove-marker --match all
  }
fi
# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh
