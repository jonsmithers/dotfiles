" personal vimrc
" Author:       Jon Smithers <mail@jonsmithers.link>
" URL:          https://github.com/jonsmithers/dotfiles/blob/master/vim/vimrc
" Last Updated: 2019-03-14

:scriptencoding utf8

if !exists('s:os')
  if has('win64') || has('win32') || has('win16')
    let s:os = 'Windows'
  elseif has('mac')
    let s:os = 'MacOS'
  else
    let s:os = 'Linux'
  endif
endif
:let g:mapleader = ' '

" Install vim-plug if it isn't already
if (s:os !=# 'Windows')
  if empty(glob('~/.vim/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
          \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    augroup vimplug
      au!
      autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
    augroup END
  endif
else
  if empty(glob('~\vimfiles\autoload\plug.vim'))
    set shell=C:\\WINDOWS\\sysnative\\WindowsPowerShell\\v1.0\\powershell.exe
    !md ~\vimfiles\autoload
    !(New-Object Net.WebClient).DownloadFile('https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim', $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath('~\vimfiles\autoload\plug.vim'))
    augroup vimplug
      au!
      autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
    augroup END
  endif
endif

" VIM PLUG
  call plug#begin('~/.vim/plugged')

    Plug 'AndrewRadev/splitjoin.vim'
    " gJ on first line to join object literal into one line
    " gS to split one-line object into multiple lines

    " Plug 'airblade/vim-gitgutter'
    " Show indicators for what's been modified/added/deleted.
    " :nmap <Leader>ga :GitGutterStageHunk<Enter>
    " :nmap <Leader>ga :GitGutterStageHunk<Enter>
    " :nmap <Leader>gH :GitGutterLineHighlightsToggle<Enter>
    " :nmap <Leader>gn :GitGutterNextHunk<Enter>
    " :nmap <Leader>gN :GitGutterPrevHunk<Enter>
    " :nmap <Leader>gP :GitGutterPreviewHunk<Enter>
    " :nmap <Leader>gu :GitGutterUndoHunk<Enter>

    Plug 'mhinz/vim-signify'
    " Git info in gutter
    " [c,]c jump to prev/next change
    " [C,]C jump to last/first change

    Plug 'alvan/vim-closetag'
    " Automatically close html tags.

    Plug 'ciaranm/detectindent'
    " Analyze current buffer and configure tabbing to match.
      nnoremap <leader>di :DetectIndent<cr>
      :let g:detectindent_preferred_indent = 2

    Plug 'chrisbra/Colorizer'
    " Show hex colors by running :ColorHighlight or :ColorToggle
    let g:colorizer_fgcontrast = 0

    Plug 'editorconfig/editorconfig-vim'
    " Configure different coding styles on a per-project basis and have vim
    " automatically adjust. There are equivalent plugins for all major code
    " editors. It's great. In a better world, every project would have a
    " .editorconfig file at its root.

    " Plug 'emilyst/match-count-statusline'
    " let g:match_count_disable_statusline = v:true
    " defines MatchCountStatusline

    Plug 'Houl/ExplainPattern-vim'

    Plug 'itchyny/lightline.vim'
    " inspired by https://statico.github.io/vim3.html#lightline-powerline-airline-and-status-bars
      set laststatus=2 "always show airline, instead of only after splitview
      set noshowmode   "lightline will show mode for me
      set showcmd      "shows size of visual selection BELOW lightline
      let g:lightline = {
      \   'active': {
      \     'left': [
      \       ['mode', 'paste'],
      \       ['filename', 'modified'],
      \       ['git_changes'],
      \     ],
      \     'right': [
      \       ['lineinfo'],
      \       ['percent'],
      \       ['readonly', 'linter_warnings', 'linter_errors', 'linter_ok'],
      \       ['obsession'],
      \     ]
      \   },
      \   'component_function': {
      \     'match_count': 'MatchCountStatusline',
      \     'obsession':   'LightlineObsessionStatus',
      \     'git_changes': 'LightLineChanges',
      \   },
      \   'component_expand': {
      \     'linter_warnings': 'LightlineLinterWarnings',
      \     'linter_errors':   'LightlineLinterErrors',
      \     'linter_ok':       'LightlineLinterOK',
      \   },
      \   'component_type': {
      \     'readonly':        'error',
      \     'linter_warnings': 'warning',
      \     'linter_errors':   'error'
      \   },
      \   'separator': {
      \     'left': '',
      \     'right': ''
      \   },
      \   'enable': {
      \     'statusline': 1,
      \     'tabline': 0
      \   }
      \ }
      " let g:lightline.separator.right = 'î‚²'
      " let g:lightline.separator.left =  'î‚°'
      function! LightlineObsessionStatus()
        if exists('*ObsessionStatus')
          return ObsessionStatus('session', 'session paused')
        endif
      endfunction
      function! LightLineChanges()
        let l:hunkSummary = v:null
        if exists('*GitGutterGetHunkSummary')
          let l:hunkSummary = GitGutterGetHunkSummary()
        elseif exists('g:loaded_signify') && sy#buffer_is_active()
          let l:hunkSummary = sy#repo#get_stats()
        endif
        if (empty(l:hunkSummary))
          return ''
        else
          let [ l:added, l:modified, l:removed ] = l:hunkSummary
          let l:total = (l:added + l:modified + l:removed)
          let l:output = ''
          if (l:added != 0)
            let l:output .= printf('+%d ', l:added)
          endif
          if (l:modified != 0)
            let l:output .= printf('~%d ', l:modified)
          endif
          if (l:removed != 0)
            let l:output .= printf('-%d ', l:removed)
          endif
          return '(' . l:output . ')'
        endif
      endfunction
      function! LightlineLinterWarnings() abort
        if (&readonly)
          return ''
        endif
        let l:counts = ale#statusline#Count(bufnr(''))
        let l:all_errors = l:counts.error + l:counts.style_error
        let l:all_non_errors = l:counts.total - l:all_errors
        return l:all_non_errors == 0 ? '' : printf('%d â–²', l:all_non_errors)
      endfunction
      function! LightlineLinterErrors() abort
        if (&readonly)
          return ''
        endif
        let l:counts = ale#statusline#Count(bufnr(''))
        let l:all_errors = l:counts.error + l:counts.style_error
        let l:all_non_errors = l:counts.total - l:all_errors
        return l:all_errors == 0 ? '' : printf('%d âœ—', l:all_errors)
      endfunction
      function! LightlineLinterOK() abort
        if (&readonly)
          return ''
        endif
        let l:counts = ale#statusline#Count(bufnr(''))
        let l:all_errors = l:counts.error + l:counts.style_error
        let l:all_non_errors = l:counts.total - l:all_errors
        return l:counts.total == 0 ? 'âœ“' : ''
      endfunction
      augroup ale_stuff
        au!
        autocmd User ALELint call s:MaybeUpdateLightline()
      augroup END
      function! s:MaybeUpdateLightline()
        " Update and show lightline but only if it's visible (e.g., not in Goyo)
        if exists('#lightline')
          call lightline#update()
        end
      endfunction

      augroup LightlineColorscheme
        autocmd!
        autocmd ColorScheme * call s:lightline_match_colorscheme()
      augroup END
      function! s:lightline_match_colorscheme() abort
        func! s:MatchesColorscheme(idx, val) abort
          let l:lightlineScheme = a:val
          let l:lightlineScheme = substitute(l:lightlineScheme, '_.*', '', '')
          let l:result = (-1 != match(g:colors_name, l:lightlineScheme))
          return l:result
        endfunc
        let l:colorschemes = s:lightline_colorscheme_list()
        call filter(l:colorschemes, function('s:MatchesColorscheme'))
        if (len(l:colorschemes) > 0)
          " echom l:colorschemes[0] . ' matches ' . g:colors_name . '. ' . string(len(l:colorschemes))
          let g:lightline.colorscheme = l:colorschemes[0]
        else
          " echom 'no lightline colorscheme for ' . g:colors_name
          if (exists('g:lightline.colorscheme'))
            unlet g:lightline.colorscheme
          endif
        endif
        if (exists('g:loaded_lightline') && exists('#lightline'))
          "                                 ^ lightline is not disabled (e.g. by Goyo)
          call lightline#init()
          call lightline#colorscheme()
          call lightline#update()
        endif
      endfunction
      function! s:lightline_colorscheme_list()
        return map(globpath(&runtimepath,'autoload/lightline/colorscheme/*.vim',1,1), "fnamemodify(v:val,':t:r')")
      endfunction

      command! -nargs=1 -complete=custom,s:lightline_colorschemes LightlineColorscheme call s:set_lightline_colorscheme(<q-args>)
      function! s:lightline_colorschemes(...) abort
        return join(s:lightline_colorscheme_list(), "\n")
      endfunction
      function! s:set_lightline_colorscheme(name) abort
        let g:lightline.colorscheme = a:name
        call lightline#init()
        call lightline#colorscheme()
        call lightline#update()
      endfunction

    " let g:lithtml=1
    if exists('g:lithtml')
      if (!empty(glob('~/git/vim-html-template-literals/'))) " 'command -v npm' takes about 150ms
        " let g:VHTL_debugging = 1
        Plug 'jonsmithers/vim-html-template-literals', { 'dir': '~/git/vim-html-template-literals/' }
      else
        Plug 'jonsmithers/vim-html-template-literals'
      endif
    endif

    Plug 'jonsmithers/pivotal-tracker-fzf.vim', (empty(glob('~/git/pivotal-tracker-fzf.vim/')) ? { 'for': 'gitcommit' } : { 'dir': '~/git/pivotal-tracker-fzf.vim' })

    " Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all --no-zsh' }
    Plug 'junegunn/fzf'
    Plug 'junegunn/fzf.vim'
    " Incredible fuzzy search for all sorts of things. Best plugin ever.

      " customize fzf colors to match color scheme
        let g:fzf_colors =
        \ { 'fg':      ['fg', 'Normal'],
          \ 'bg':      ['bg', 'Normal'],
          \ 'hl':      ['fg', 'Comment'],
          \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
          \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
          \ 'hl+':     ['fg', 'Statement'],
          \ 'info':    ['fg', 'PreProc'],
          \ 'border':  ['fg', 'Ignore'],
          \ 'prompt':  ['fg', 'Conditional'],
          \ 'pointer': ['fg', 'Exception'],
          \ 'marker':  ['fg', 'Keyword'],
          \ 'spinner': ['fg', 'Label'],
          \ 'header':  ['fg', 'Comment'] }

      " fzf bindings
        :command! -bang -nargs=* Rg  call fzf#vim#grep('rg --column --line-number --no-heading --color=always               '.shellescape(<q-args>).'| tr -d "\017"', 1, <bang>0)
        :command! -bang -nargs=* Rgi call fzf#vim#grep('rg --column --line-number --no-heading --color=always --ignore-case '.shellescape(<q-args>).'| tr -d "\017"', 1, <bang>0)
        :command! -nargs=* Rgexpand :exec 'Rg ' . expand(<q-args>)

        "search for word in working directory
        :nnoremap <Leader>sw    :Rg  <Enter>
        :vnoremap <Leader>s     y:Rg "<Enter>

        :nnoremap <C-k>         :Buffers<Enter>
        :nnoremap <C-p>         :Files<Enter>
        :nnoremap <Leader>or    :History<Enter>
        :nnoremap <Leader>ft    :Filetypes<enter>
        :nnoremap <Leader>/     :History/<Enter>
        :nnoremap q;            :History:<Enter>
        " (note - you can call histdel("cmd", "regexp") to delete mistaken history items)
        " :nmap <Leader>f~    :FZF ~<Enter>

        " fuzzy relative filepath completion!
        inoremap <expr> <c-x><c-f> fzf#vim#complete#path(
              \ "find . -path '*/\.*' -prune -o -print \| sed '1d;s:^..::'",
              \ fzf#wrap({'dir': expand('%:p:h')}))
        inoremap <c-x>F <c-x><c-f>
              " Ctrl-X Shift-F will provide native c-x c-f functionality

    Plug 'junegunn/goyo.vim', { 'on': 'Goyo' }
    " Distraction free mode. Good for coding and as well as prose writing.
      let g:goyo_width = 81
      " make vim close the First time you do :quit
      " https://github.com/junegunn/goyo.vim/wiki/Customization
      function! s:goyo_enter()
        let b:quitting = 0
        let b:quitting_bang = 0
        augroup goyo_buffer
          au!
          autocmd QuitPre <buffer> let b:quitting = 1
        augroup END
        cabbrev <buffer> q! let b:quitting_bang = 1 <bar> q!
      endfunction
      function! s:goyo_leave()
        " Quit Vim if this is the only remaining buffer
        if b:quitting && len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) == 1
          if b:quitting_bang
            qa!
          else
            qa
          endif
        endif
      endfunction
      augroup goyo_stuff
        au!
        autocmd User GoyoEnter call <SID>goyo_enter()
        autocmd User GoyoLeave call <SID>goyo_leave()
      augroup END

    Plug 'junegunn/vim-journal'

    Plug 'junegunn/limelight.vim'

    Plug 'junegunn/rainbow_parentheses.vim'
    let g:rainbow#pairs = [['(', ')'], ['[', ']'], ['{', '}']]

    Plug 'junegunn/gv.vim', { 'on': 'GV' }
    " :GV to open git view (commit browser)

    Plug 'junegunn/vader.vim', { 'on': 'Vader', 'for': 'vader' }

    Plug 'junegunn/vim-easy-align'
    " Align chunks of code on a character/regex. Makes it really easy to have
    " nice formatting.
      :xmap     ga <Plug>(EasyAlign)
      :nnoremap ga <Plug>(EasyAlign)

    Plug 'justinmk/vim-dirvish'
    " directory viewer
      " sort folders at top
      let g:dirvish_mode = ':sort ,^.*[\/],'
      augroup dirvish_stuff
        au!
        autocmd FileType dirvish setlocal nonumber
        autocmd FileType dirvish silent! unmap <buffer> <C-p>
      augroup END

    Plug 'markonm/traces.vim'
    " show a live preview of :substitute

    " Plug 'jonsmithers/vim-localhistory', { 'dir': '~/git/vim-localhistory/' }
    " let g:lh_basedir = '~/.vim/local_history/'
    " let g:local_history_disable_mappings = 1
    " let g:lh_autobackup_first = 1
    " let g:lh_quiet = 1
    " let g:lh_autobackup_frequency = 60
    " LHwrite         : write a backup with date
    " LHwrite <name>  : write a named backup (snapshot)
    " LHdated         : load a backup with a date
    " LHsnapshot      : load a snapshot
    " LHdiff          : select a backup and open a split diff window
    " LHdelete        : delete backups for current dir (all types)
    " LHall           : load any backup

    Plug 'mg979/vim-visual-multi'
    let g:VM_mouse_mappings = 1
    let g:VM_no_meta_mappings = 1
    " multiple cursors. Seems to be faster than 'terryma/vim-multiple-cursors'.
    "
    " Ctrl-N on a word to multiply your cursor on subsequent matches for batch
    " editing. (Ctrl-S) to skip
    "
    " Ctrl-Up/Down to expand multiline cursor.
    "
    " \A to select all matches of word

    if (!exists('g:lithtml'))
      Plug 'mxw/vim-jsx'
    endif

    " Plug 'neoclide/coc.nvim', {'tag': '*', 'do': { -> coc#util#install()}}
    "
    " CocInstall coc-json
    " CocInstall coc-tsserver
    " CocInstall coc-html
    " CocInstall coc-css

    Plug 'nelstrom/vim-visual-star-search'
    " Bring "*" key behavior into visual mode. Extremely useful.
    " (see ":help *").

    Plug 'othree/html5.vim'
    let g:html_indent_style1  = 'inc'
    let g:html_indent_script1 = 'inc'

    if !exists('g:dumb_js')
      Plug 'pangloss/vim-javascript'
      " Vastly improved syntax highlighting.
    endif
      let g:javascript_plugin_jsdoc = 1
      command! FastJS let g:dumb_js = 1 | source $MYVIMRC
      command! SlowJS unlet g:dumb_js | source $MYVIMRC

    Plug 'othree/eregex.vim'
    " Lets me use more standard regex.
      " Search with :M/[regex]
      " Substitute with <range> :S/regex/string/
      let g:eregex_default_enable = 0
      nnoremap <Leader>m/ :M/

    Plug 'ryanoasis/vim-devicons'
    " Shows pretty little icons when you use a nerdfont in your terminal.
      if hostname() =~# 'Smithers.local'
        let g:webdevicons_enable = 1
      else
        let g:webdevicons_enable = 0
      endif
    Plug 'scrooloose/nerdtree', { 'on': ['NERDTreeFind', 'NERDTreeClose', 'NERDTreeToggle'] }
    " Project tree sidebar that kind of defies the philosophy of vim
      let g:NERDTreeHijackNetrw=0 " let dirvish replace netrw

      :nnoremap <Leader>tt :NERDTreeToggle<enter>
      :nnoremap <Leader>tf :NERDTreeFind<enter>
      " close nerdtree if it's the only remaining buffer

    if (has('python') || has('python3'))
      Plug 'SirVer/ultisnips'
      " I use this for Polymer element templates.
      let g:UltiSnipsSnippetDirectories = ['~/.vim/UltiSnips', 'UltiSnips']
      " ^ workaround bug https://github.com/SirVer/ultisnips/issues/711
    endif

    if (!empty(glob('/usr/local/bin/npm')) || !empty(glob('/home/smithers/.npm-global/bin/npm'))) " 'command -v npm' takes about 150ms
      Plug 'ternjs/tern_for_vim', { 'do': 'npm install' }
    " Intelligent completion for JavaScript. It's amazing.
      let g:tern_show_signature_in_pum = 1
      set updatetime=1000
      :nnoremap <Leader>td :TernDoc<cr>
      augroup tern_stuff
        au!
        autocmd CompleteDone javascript pclose
      augroup END
    endif

    Plug 'tomtom/tcomment_vim'
    " Toggle code comments. Mapped to Ctrl-//
      let g:tcomment#replacements_xml = {} " don't substitute weird characters when commenting html lines

    Plug 'tpope/vim-eunuch'
    ":Delete, :Chmod, :SudoWrite, :Rename, :Mkdir

    Plug 'tpope/vim-fugitive'
    Plug 'tpope/vim-rhubarb'
    " Various integrated git tools. I use this a lot.
      nnoremap <Leader>gb :Gblame -w<cr>
      " ~        reblame at hovered commit
      " A        resize to author column
      " D        resize to date column
      " p        preview commit
      " o        open commit in split
      " O        open commit in tab
      nnoremap <leader>gs :Gstatus<cr>
      " http://vimcasts.org/episodes/fugitive-vim-working-with-the-git-index/
      " c-n, c-p jumps to files
      " p        runs add --patch
      " cc       runs commit
      " -        stages/unstages
      " D        diff
      nnoremap <leader>gd :Gvdiff<cr>
      "          (left is index (staged), right is working)
      "          dp      diffput
      "          do      diffget (think "obtain")
      "          :w      write to index/working copy
      "          [c,]c   jump to prev/next change
      "          c-w c-o nice way to exit
      "          c-w c-w goes between columns

    Plug 'tpope/vim-rsi'
    " add readline keybindings http://readline.kablamo.org/emacs.html

    Plug 'tpope/vim-unimpaired'

    Plug 'tpope/vim-obsession'
    " :Obsession ~/.vim/obsessions/
    " :source ~/.vim/obsessions/Session.vim
    command! -bang Sesh call Sesh(<bang>0)
    function! Sesh(bang)
      let l:file = $HOME . '/.vim/obsessions/Session.vim'
      let l:isTracking = !empty(ObsessionStatus('tracking', '')) " true for both off and pused

      if (a:bang) " replace persisted session
        if (l:isTracking)
          Obsession!
        endif
        if (filereadable(l:file))
          call delete(l:file)
        endif
        exec 'Obsession ' . l:file
      else " restore session if possible or start tracking current
        if (!l:isTracking)
          if (filereadable(l:file))
            exec 'source ' . l:file
          else
            exec 'Obsession ' . l:file
          endif
        else
          echom 'already tracking'
        endif
      endif
    endfunction

    if (!empty(glob('~/Dropbox/vimwiki')))
      Plug 'vimwiki/vimwiki'
    " Quick access to a personal wiki. In vim.
      let g:vimwiki_list = [
      \   {
      \     'path': '$HOME/Dropbox/vimwiki/md',
      \     'syntax': 'markdown',
      \     'ext': '.md',
      \   },
      \   {
      \     'path': '$HOME/Dropbox/vimwiki'
      \   },
      \ ] " 'syntax': 'markdown', 'ext': '.md'}]
    endif

    Plug 'w0rp/ale'
    " Asynchronous linting of all kinds. I use this for bash scripting, fish
    " shell, vim, javascript, and more.
      let g:ale_linters = {
        \ 'html': ['eslint'],
        \ 'javascript': ['eslint'],
        \ 'java': [],
      \}
      let g:ale_linter_aliases = { 'html': ['html', 'javascript'] }
      let g:ale_echo_msg_format = '%linter%: %s (%code%)'
      let g:ale_fixers = {
            \ 'javascript': ['eslint'],
            \ 'html': ['eslint']
            \}
      :nnoremap <Leader>an :ALENextWrap<Enter>


    " Plug 'wellle/targets.vim'
    " Advanced vim text objects. Sometimes this is slow.

    Plug 'whiteinge/diffconflicts'
    " git config --global merge.tool diffconflicts
    " git config --global mergetool.diffconflicts.cmd 'vim -c DiffConflicts "$MERGED" "$BASE" "$LOCAL" "$REMOTE"'
    " git config --global mergetool.diffconflicts.trustExitCode true
    " git config --global mergetool.keepBackup false
    " git mergetool <file>

    if (!empty(glob('~/Dropbox/vim-notes')))
      Plug 'xolox/vim-notes'
      Plug 'xolox/vim-misc'
    " Quickly write and access notes that sync to Dropbox
      let g:notes_directories = ['~/Dropbox/vim-notes']
      let g:notes_smart_quotes = 0
      let g:notes_suffix = '.txt'
      let g:notes_conceal_bold = 0
    endif

    " language syntaxes
    Plug 'dag/vim-fish'
    Plug 'leafgarland/typescript-vim'
    Plug 'luan/vim-concourse'
    Plug 'posva/vim-vue'
    Plug 'tfnico/vim-gradle'
    Plug 'vim-scripts/groovyindent-unix'
    let g:concourse_tags_autosave = 0

    " colorschemes
    if (has('termguicolors'))
      set termguicolors
    else
      set t_Co=256
    endif
    Plug 'cormacrelf/vim-colors-github'
    Plug 'arcticicestudio/nord-vim'
    Plug 'dracula/vim'
    Plug 'junegunn/seoul256.vim'
    Plug 'KKPMW/sacredforest-vim'
    Plug 'mhartington/oceanic-next'
    Plug 'morhetz/gruvbox'
    Plug 'nanotech/jellybeans.vim'
    Plug 'nightsense/snow'
    Plug 'NLKNguyen/papercolor-theme'
    Plug 'rakr/vim-one'
    Plug 'romainl/Apprentice'
    Plug 'chriskempson/base16-vim'

    if has('mac')
      Plug 'junegunn/vim-xmark', { 'do': 'make' }
    endif

    "run :PlugInstall to install new plugins
  call plug#end()

  if (!empty(glob('~/.vim/vim-plug-extras.vim')))
    source ~/.vim/vim-plug-extras.vim
  endif

  if (hostname() ==# 'Smithers.local')
    let g:python3_host_prog='/usr/local/bin/python3'
  elseif (hostname() ==# 'zamperini4')
    let g:python3_host_prog='/usr/bin/python3'
  endif

" Key Bindings

  nnoremap <leader>; :
  vnoremap <leader>; :

  cnoremap <C-k> <up>
  cnoremap <C-j> <down>

  " search and replace
  :vnoremap <C-r> y:%s/<C-r>0/<C-r>0/gc<left><left><left>

  " insert mode shortcuts
    " :inoremap <C-@> <C-Space>
    " :inoremap <C-Space> <C-x><C-o>
    :inoremap jk <Esc>
    " :inoremap II <Esc>I
    " :inoremap AA <Esc>A
    :inoremap jl <Esc>:
    :imap \t <Esc>:r! date "+\%Y\%m\%d"<Enter>kJA

  " normal mode shortucts
    "insert time:
    :nnoremap <Leader>it :r! date "+\%Y\%m\%d"<Enter>kJ
    :com! InsertDate :r! date "+\%Y\%m\%d"

    " clear search
    :nnoremap <leader>sdf :let @/ = ''<cr>

    :nnoremap <C-h> 5zh
    :nnoremap <C-l> 5zl
    :nnoremap Q <nop>
    :nnoremap <Leader>T :enew<cr>
    let g:BASH_Ctrl_j = 'off' "this is undocumented!
    :nnoremap <Leader>x :NERDTreeClose<enter>:bd<enter>
    :nnoremap <Leader>X :NERDTreeClose<enter>:bd!<enter>
    :nnoremap <Leader><Leader> :w<Enter>
    :nnoremap <Leader><Tab> :b#<enter>
    " switch to most recent buffer
    :nnoremap <Leader>ss :syntax sync fromstart<enter>
    :nnoremap <Leader>BD :bufdo bd<enter>

    :let g:html_wrong_comments=1 "be lenient with html comment syntax. This is a must-have for documented Polymer code.

    map <F10> :echo map(synstack(line("."), col(".")), "synIDattr(v:val, 'name')")<cr>

    " CODE COPIED FROM https://github.com/zenbro/dotfiles/blob/master/.nvimrc#L151-L187
      " If split in given direction exists - jump, else create new split
      function! JumpOrOpenNewSplit(key, cmd, fzf) " {{{
        let l:current_window = winnr()
        execute 'wincmd' a:key
        if l:current_window == winnr()
          execute a:cmd
          if a:fzf
            Files
          else
            Dirvish %:p:h
          endif
        else
          if a:fzf
            Files
          endif
        endif
      endfunction " }}}
      nnoremap <silent> <Leader>hh :call JumpOrOpenNewSplit('h', ':leftabove vsplit', 0)<CR>
      nnoremap <silent> <Leader>ll :call JumpOrOpenNewSplit('l', ':rightbelow vsplit', 0)<CR>
      nnoremap <silent> <Leader>kk :call JumpOrOpenNewSplit('k', ':leftabove split', 0)<CR>
      nnoremap <silent> <Leader>jj :call JumpOrOpenNewSplit('j', ':rightbelow split', 0)<CR>
      " Same as above, except it opens unite at the end
      nnoremap <silent> <Leader>h<Space> :call JumpOrOpenNewSplit('h', ':leftabove vsplit', 1)<CR>
      nnoremap <silent> <Leader>l<Space> :call JumpOrOpenNewSplit('l', ':rightbelow vsplit', 1)<CR>
      nnoremap <silent> <Leader>k<Space> :call JumpOrOpenNewSplit('k', ':leftabove split', 1)<CR>
      nnoremap <silent> <Leader>j<Space> :call JumpOrOpenNewSplit('j', ':rightbelow split', 1)<CR>
      " Delete all hidden buffers
      nnoremap <silent> <Leader><BS>b :call DeleteHiddenBuffers()<CR>
      function! DeleteHiddenBuffers() " {{{
        let l:tpbl=[]
        call map(range(1, tabpagenr('$')), 'extend(l:tpbl, tabpagebuflist(v:val))')
        for l:buf in filter(range(1, bufnr('$')), 'bufexists(v:val) && index(l:tpbl, v:val)==-1')
          silent execute 'bwipeout' l:buf
        endfor
      endfunction " }}}

    command! FormatJSON :%!python -m json.tool

    if has('nvim')
      tmap <C-u> <C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k>
      tmap <C-d> <C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j>
    endif

  " terminal mode shortcuts
    if has('nvim')
      :tnoremap <C-w> <C-\><C-n><C-w>
      " conflicts with FZF
      " :tmap <C-j> <C-\><C-n>:bprevious<Enter>
      " :tmap <C-k> <C-\><C-n>:bnext<Enter>
    endif

" Miscellanious commands
  com! JV exec "edit ~/.vim/plugged"

  " open current file in VSCode or Idea (and jump to cursor location)
  :command! OpenInVSCode    exe "silent !code --goto '" . expand("%") . ":" . line(".") . ":" . col(".") . "'"                    | redraw!
  :command! OpenCwdInVSCode exe "silent !code '" . getcwd() . "' --goto '" . expand("%") . ":" . line(".") . ":" . col(".") . "'" | redraw!
  :command! OpenInIdea      exe "silent !idea '" . getcwd() . "' '" . expand("%") . ":" . line(".") . "'"                         | redraw!
  :command! Quit2Idea       exe "silent !idea '" . getcwd() . "' '" . expand("%") . ":" . line(".") . "'"                         | redraw! | quit

  " open url on current line
  func! OpenUrl()
    exec 'silent !python -mwebbrowser "'.(fnameescape(matchstr (getline('.'), 'https\?://[a-zA-Z0-9\./\-?=\&+@,!:_#]\+[^,.) \"]'))).'" 2> /dev/null > /dev/null' | redraw!
  endfu
  com! TestUrl exec 'echom            "'.(fnameescape(matchstr (getline('.'), 'https\?://[a-zA-Z0-9\./\-?=\&+@,!:_#]\+[^,.) \"]'))).'"'
  nnoremap <Leader>ou :call OpenUrl()<Enter>
  " toggle plugins and syntax to make vim really fast
  " com! Fast :GitGutterToggle | :ALEToggle | :if exists("g:syntax_on") | syntax off | else | syntax enable | endif
  com! Fast :ALEDisable | syntax off
  com! Slow :ALEEnable  | syntax on

  " https://github.com/mhinz/vim-galore#saner-behavior-of-n-and-n
  nnoremap <expr> n  'Nn'[v:searchforward]
  nnoremap <expr> N  'nN'[v:searchforward]
  " https://github.com/mhinz/vim-galore#saner-command-line-history
  cnoremap <c-n>  <down>
  cnoremap <c-p>  <up>
  " Saner CTRL L: https://github.com/mhinz/vim-galore#saner-ctrl-l
  nnoremap <leader>l :nohlsearch<cr>:diffupdate<cr>:syntax sync fromstart<cr><c-l>
  " Quickly Move Current Line: https://github.com/mhinz/vim-galore#matchit
  nnoremap [e  :<c-u>execute 'move -1-'. v:count1<cr>
  nnoremap ]e  :<c-u>execute 'move +'. v:count1<cr>
  " Quickly Add Empty Lines: https://github.com/mhinz/vim-galore#quickly-add-empty-lines
  nnoremap [<space>  :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[
  nnoremap ]<space>  :<c-u>put =repeat(nr2char(10), v:count1)<cr>
  " Quickly Edit Your Macros:  https://github.com/mhinz/vim-galore#quickly-edit-your-macros
  nnoremap <leader>m  :<c-u><c-r><c-r>='let @'. v:register .' = '. string(getreg(v:register))<cr><c-f><left>
  " Change Cursor Style Dependent On Mode: https://github.com/mhinz/vim-galore#change-cursor-style-dependent-on-mode
  if empty($TMUX)
    if (s:os ==? 'Linux')
      augroup curshapestuff
        au!
        au VimEnter,InsertLeave * silent execute '!echo -ne "\e[2 q"' | redraw!
        au InsertEnter,InsertChange *
              \ if v:insertmode == 'i' |
              \   silent execute '!echo -ne "\e[6 q"' |
              \ elseif v:insertmode == 'r' |
              \   silent execute '!echo -ne "\e[4 q"' |
              \ endif
        au VimLeave * silent execute '!echo -ne "\e[ q"' |
      augroup END
    elseif (s:os ==? 'MacOS')
      let &t_SI = "\<Esc>]50;CursorShape=1\x7"
      let &t_EI = "\<Esc>]50;CursorShape=0\x7"
      let &t_SR = "\<Esc>]50;CursorShape=2\x7"
    endif
  else
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
    let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
  endif

" Viewer
  func! Reader()
      :AnsiEsc
      set laststatus=0
      set nonumber
  endfu

" Experimental scroll mode
  nnoremap zs 0zz:call dotfile_extras#ToggleScrollMode()<Enter>

" Prose
  set nojoinspaces  " prevent vim from inserting 2 spaces after periods.
  com! ProseMode    call dotfile_extras#ProseMode()
  com! SoftWrapMode call dotfile_extras#SoftWrappedProcessorMode()
  nnoremap <F4>    :call dotfile_extras#ToggleTerm()<CR>


  map <F6> :let $VIM_DIR=expand('%:p:h')<CR>:terminal<CR>cd $VIM_DIR<CR>clear<CR>

"# GUI Customization
  if has('gui_running')
    set background=dark
    set autoread        "auto-load changes from disk
    if (s:os ==? 'MacOS')
      set guifont=Monaco:h16
    elseif (s:os ==? 'Windows')
      set guifont=Courier_New:h12
    endif

    :set guioptions-=m  "remove menu bar
    :set guioptions-=T  "remove toolbar
    :set guioptions-=r  "remove right-hand scroll bar
    :set guioptions-=L  "remove left-hand scroll bar
  endif

" Rare Tools
  func! HighlightTrailingSpace()
    highlight TrailingSpace ctermbg=red ctermfg=white guibg=#592929
    match TrailingSpace /\s\+\n/
  endfu
  command! TrailingSpaceHighlight call HighlightTrailingSpace()
  command! TrailingSpaceDeleteAll :%s/\s\+\n/\r/gc

  " call clearmatches() " http://vim.wikia.com/wiki/Highlight_long_lines
  func! HighlightOverlength()
    highlight OverLength ctermbg=red ctermfg=white guibg=#592929
    match OverLength /\%81v.\+/
  endfu
  com! FormatPlusBullets setlocal fo+=n | setlocal flp=^\\s*\\(+\\\\|\\d\\+\\.\\)\\s* " allows you to use '+' as a bullet character ('-' and '*' are already covered by the format option 'q')

" Basics
  if filereadable($VIMRUNTIME . '/defaults.vim')
    if !exists(':DiffOrig') " avoid unnecessary re-sourcing. For some reason it takes about 600ms
      source $VIMRUNTIME/defaults.vim " new in vim 8
    endif
    packadd! matchit " bundled default plugin
  else
    set wildmenu      "show suggestions for vim commands
    set incsearch     "incremental search (something else also turns this on)
    syntax enable
    set mouse=a       " default in Vim 8 defaults.vim
    set backspace=indent,eol,start
    set history=200		" keep 200 lines of command line history
  endif
  set ttimeoutlen=0 "timeout instantly when pressing esc during visual mode
  set foldmethod=syntax
  set foldlevelstart=99
  set nowrap
  set ignorecase    "search ignores case
  set smartcase     "unless there's a capital letter
  set number
  set autoindent
  set smartindent
  set hlsearch      " default in NeoVim

  set splitbelow    " more natural split behavior
  set splitright    " more natural split behavior

  set hidden        " leave buffers without saving

  set completeopt=menuone,longest,preview " make completion menu awesome
  set directory=/var/tmp,/tmp,.
  set backupdir=~/.config/smithers/vimbackup,~/.config/vimbackup,/var/tmp
  set backup
  augroup vimrc_backup
    autocmd!
    au BufWritePre * let &bex = '-' . strftime("%Y%m%d-%H%M%S") . '.vimbackup'
  augroup END

  set sessionoptions-=options " for some reason, vim won't restore with syntax highlighting without this. https://stackoverflow.com/questions/9281438/syntax-highlighting-doesnt-work-after-restore-a-previous-vim-session

  " disable audible and visual bells set noerrorbells https://github.com/mhinz/vim-galore#disable-audible-and-visual-bells
  "set noerrorbells "this does not work
  "set novisualbell
  "set t_vb=
  set belloff=all

  " diffing
  if has('patch-8.1.0360')
    set diffopt+=algorithm:patience
    set diffopt+=indent-heuristic
  endif

  :cabbrev h vert h
                    " execute [:h QUERY] to open help page in vertical split buffer

  if !&scrolloff
    set scrolloff=3 " Show next 3 lines while scrolling.
  endif
  if !&sidescrolloff
    set sidescrolloff=5 " Show next 5 columns while side-scrolling.
  endif
  "(source: http://nerditya.com/code/guide-to-neovim/)

" Tabs
  set expandtab     " SPACES over TABS
  set smarttab      " delete multiple spaces at once (as if deleting a tab character)
  com! -nargs=1 Tab      set      tabstop=<args> | set      shiftwidth=<args> "| set softtabstop=<args>
  com! -nargs=1 LocalTab setlocal tabstop=<args> | setlocal shiftwidth=<args> "| set softtabstop=<args>
  " if (hostname() == "Smithers.local")
  "   :Tab 4
  " elseif (hostname() == "zamperini2")
  "   :Tab 2
  " elseif (hostname() == "zamperini4")
  "   :Tab 2
  " endif

  " autocmd Filetype vimrc setlocal expandtab tabstop=2 shiftwidth=2 softtabstop=2

  " func! JSFormatting()
  "   autocmd FileType javascript setlocal equalprg=js-beautify\ --stdin
  " endfu

" Theme shortcuts
  com! Default    set background=dark  | colorscheme default
  com! DarkGruv   set background=dark  | colorscheme gruvbox
  com! DarkOcean  set background=dark  | colorscheme OceanicNext
  com! DarkPaper  set background=dark  | colorscheme PaperColor
  com! DarkOne    set background=dark  | colorscheme one
  com! DarkSeoul  set background=dark  | colorscheme seoul256
  com! DarkSacredForest                  colorscheme sacredforest
  com! DarkApprentice                    colorscheme apprentice
  com! DarkSnow   set background=dark  | colorscheme snow
  com! DarkNord   set background=dark  | colorscheme nord
  com! LightOne   set background=light | colorscheme one
  com! LightGruv  set background=light | colorscheme gruvbox
  com! LightOcean set background=light | colorscheme OceanicNextLight
  com! LightPaper set background=light | colorscheme PaperColor
  com! LightSeoul set background=light | colorscheme seoul256
  com! LightSnow  set background=light | colorscheme snow
  com! LightGitHub set background=light | colorscheme github

  augroup colorschemespellingfix
    autocmd!
    autocmd ColorScheme * highlight SpellBad term=reverse ctermbg=224 gui=undercurl guisp=Yellow guibg=NONE
    " ^ termguicolors relies on undercurl for misspellings, but many
    " terminals don't have that.
  augroup END

  if has('nvim')
    let $NVIM_TUI_ENABLE_TRUE_COLOR=1
    :DarkGruv
    set nofixeol      " don't insert EOL at end of file
  else
    colorscheme apprentice
  end

" simple session restoration http://vim.wikia.com/wiki/Go_away_and_come_back
  function! MakeSession()
    let b:sessiondir = $HOME . '/.vim/sessions' . getcwd()
    if (filewritable(b:sessiondir) != 2)
      exe 'silent !mkdir -p ' b:sessiondir
      redraw!
    endif
    let b:filename = b:sessiondir . '/session.vim'
    exe 'mksession! ' . b:filename
  endfunction

  function! LoadSession()
    let b:sessiondir = $HOME . '/.vim/sessions' . getcwd()
    let b:sessionfile = b:sessiondir . '/session.vim'
    if (filereadable(b:sessionfile))
      exe 'source ' b:sessionfile
    else
      echo 'No session loaded.'
    endif
  endfunction
  " au VimEnter * nested if argc() == 0 | :call LoadSession() | endif
  augroup session_saving
    au!
    au VimLeave * :call MakeSession()
  augroup END
  com! LoadSession call LoadSession()

" Auto Commands
  augroup vimrc_autocomamnds
    autocmd!

    " custom filetype behaviors
    autocmd FileType gitcommit setlocal spell
    autocmd FileType gitcommit call s:StartInsertIfEmpty()
    autocmd FileType gitcommit set comments+=fb:-,fb:+,fb:*
    autocmd FileType gitcommit set formatoptions+=cq
    autocmd FileType gitcommit normal gg
    " ^ workaround weird issue where caret sometimes starts 2 lines down
    autocmd FileType text     setlocal spell
    autocmd Filetype markdown setlocal spell
    " correct formatting for checklists
    autocmd Filetype markdown set comments-=fb:-
    autocmd Filetype markdown set comments+=fb:-\ [\ ]
    autocmd Filetype markdown set comments+=fb:-\ [X]
    autocmd Filetype markdown set comments+=fb:-
    let g:markdown_folding = 1 " enable folding via vim's native markdown plugin

    function! s:StartInsertIfEmpty()
      if (empty(getline(1)))
        startinsert!
      endif
    endfunction

    if (v:version >= 810)
      autocmd TerminalOpen * setlocal nonumber norelativenumber
    endif

    " auto-reload vimrc whenever I save it
    autocmd BufWritePost vimrc,.vimrc, source $MYVIMRC | call lightline#disable() | call lightline#enable()

    " disable syntax when editing huge files so vim stays snappy
    autocmd Filetype * if (getfsize(@%) > 500000) | setlocal syntax=OFF | endif

    " code execution
    autocmd Filetype python     nnoremap <buffer> <space>py :!python %<cr>
    "autocmd Filetype javascript nnoremap <buffer> <space>js :!node %<cr>
    " autocmd Filetype javascript nnoremap <buffer> <space>js :ter ++rows=10 node %<cr>k
    autocmd Filetype javascript nnoremap <buffer> <space>js o:call RunNodeTerm()<cr>h
    autocmd Filetype javascript,html call MakeJSKeys()
    autocmd Filetype python set omnifunc=pythoncomplete#Complete
    autocmd Filetype vim call MakeVimKeys()

  augroup END

  function! RunNodeTerm()
    call term_start('node ' . expand('%'), { 'vertical': 1, 'term_cols': 80, 'norestore': 1 })
  endfunction
  function! MakeJSKeys()
    :nnoremap <buffer> <Leader>il oconsole.log();F)i
    :nnoremap <buffer> <Leader>iL oconsole.log('%c', 'font-size:15px');F,hi
    :nnoremap <buffer> <Leader>liw yiwoconsole.log('0', 0);<Esc>
    :nnoremap <buffer> <Leader>lif yiwoconsole.log('0()');<Esc>
    :nnoremap <buffer> <Leader>liF yiwoconsole.log('%c0()', 'font-size:15px');<Esc>^2w
    :nnoremap <buffer> <Leader>gif yiwf{oconsole.group('0');<Esc>]}Oconsole.groupEnd();<Esc>^
  endfunction
  function! MakeVimKeys()
    :nnoremap <buffer> <Leader>il oechom ''i
  endfunction

  " Example Usages:
  " :MakeEslint %
  " :MakeEslint src/ test/
  command! -nargs=? MakeEslint call dotfile_extras#MakeEslint(<q-args>)

" THIS IS DEPRECATED. SEE NEXT SECTION
if !empty(glob('~/.vimrc-smithers')) " When I download this vimrc to a system that isn't mine
  command! RedownloadSmithersVimrc call RedownloadSmithersVimrcFunc()
  function! RedownloadSmithersVimrcFunc()
    silent !curl https://raw.githubusercontent.com/jonsmithers/dotfiles/master/vim/vimrc > ~/.vimrc-smithers
    silent !mkdir -p ~/.vim/autoload
    silent !curl https://raw.githubusercontent.com/jonsmithers/dotfiles/master/vim/dotfile_extras.vim > ~/.vim/autoload/dotfile_extras.vim
    redraw!
  endfunction
endif

if !empty(glob('~/.config/smithers/.vimrc'))

  " HOW TO UNINVASIVELY USE MY VIM CONFIG ON SOMEONE ELSES COMPUTER:
  " mkdir -p ~/.config/smithers
  " curl https://raw.githubusercontent.com/jonsmithers/dotfiles/master/vim/vimrc > ~/.config/smithers/.vimrc
  " vim -Nu ~/.config/smithers/.vimrc
  " # ln -s ~/.config/smithers/.vimrc ~/.vimrc

  set runtimepath+=~/.config/smithers/.vim

  command! RedownloadSmithersDotfiles call RedownloadSmithersDotfilesFunc()
  function! RedownloadSmithersDotfilesFunc()

    silent !curl https://raw.githubusercontent.com/jonsmithers/dotfiles/master/vim/vimrc > ~/.config/smithers/.vimrc
    silent !curl https://raw.githubusercontent.com/jonsmithers/dotfiles/master/vim/dot_config_smithers.txt > ~/.config/smithers/readme.txt

    silent !mkdir -p ~/.config/smithers/.vim/autoload
    silent !curl https://raw.githubusercontent.com/jonsmithers/dotfiles/master/vim/dotfile_extras.vim > ~/.config/smithers/.vim/autoload/dotfile_extras.vim

    silent !mkdir -p ~/.config/smithers/.vim/spell
    silent !curl https://raw.githubusercontent.com/jonsmithers/dotfiles/master/vim/en.utf-8.add > ~/.config/smithers/.vim/spell/en.utf-8.add

    silent !mkdir -p ~/.config/smithers/bin
    silent !curl https://raw.githubusercontent.com/jonsmithers/dotfiles/master/git/git-tracker > ~/.config/smithers/bin/git-tracker
    silent !chmod +x                                                                             ~/.config/smithers/bin/git-tracker
    silent !curl https://raw.githubusercontent.com/jonsmithers/dotfiles/master/git/git-website > ~/.config/smithers/bin/git-website
    silent !chmod +x                                                                             ~/.config/smithers/bin/git-website

    silent !mkdir -p ~/.config/smithers/vimbackup

    " clean up my old way of doing this
    if (!empty(glob('~/.vimrc-smithers')))
      silent !rm ~/.vimrc-smithers
    endif
    if (!empty(glob('~/.vim/autoload/dotfile_extras.vim')))
      silent !rm ~/.vim/autoload/dotfile_extras.vim
    endif
    if (!empty(glob('~/.config/smithers/bin/tracker')))
      silent !rm ~/.config/smithers/bin/tracker
    endif

    redraw!
  endfunction
endif

augroup updatetimestamp
  au!
  autocmd BufWritePre vimrc,.vimrc,dotfile_extras.vim       call UpdateTimeStamp()
  autocmd BufWritePre en.utf-8.add,git-tracker,git-website  call UpdateTimeStamp()
augroup END
function! UpdateTimeStamp()
  " ignore for fugitive files
  if (match(expand('%'), '^fugitive') == 0)
    return
  endif
  let l:save_view = winsaveview()
  if (line('$') <= 10)
    silent! keeppatterns    :%s/\(^\("\|#\) Last Updated:\)\zs.*/\=' ' . strftime('%Y-%m-%d')
  else
    silent! keeppatterns :1,10s/\(^\("\|#\) Last Updated:\)\zs.*/\=' ' . strftime('%Y-%m-%d')
  endif
  call winrestview(l:save_view)
endfunction

command! CheckForSmithers exec "silent! !echo This is Smithers\\' vimrc" | q
